// Code generated by make generate-methods DO NOT EDIT.

package deribit

import (
	"fmt"

	"github.com/adampointer/go-deribit/models/notifications"
	"github.com/adampointer/go-deribit/models/public"
	"github.com/mitchellh/mapstructure"
)

// SubscribeBookInterval subscribes to the book.{instrument_name}.{group}.{depth}.{interval} channel
func (e *Exchange) SubscribeBookInterval(instrument_name, group, depth, interval string) (chan *notifications.BookInstrumentNameGroupDepthIntervalRepeated, error) {
	chans := []string{fmt.Sprintf("book.%s.%s.%s.%s", instrument_name, group, depth, interval)}
	if _, err := e.PublicSubscribe(&public.SubscribeRequest{Channels: chans}); err != nil {
		return nil, fmt.Errorf("error subscribing to channel: %s", err)
	}
	c := make(chan *RPCNotification)
	out := make(chan *notifications.BookInstrumentNameGroupDepthIntervalRepeated)
	sub := &RPCSubscription{Data: c, Channel: chans[0]}
	e.subscriptions[chans[0]] = sub

	go func() {
	Loop:
		for {
			select {
			case n := <-c:
				var ret notifications.BookInstrumentNameGroupDepthIntervalRepeated
				if err := mapstructure.Decode(n.Params.Data, &ret); err != nil {
					e.errors <- fmt.Errorf("error decoding notification: %s", err)
				}
				out <- &ret
			case <-e.stop:
				break Loop
			}
		}
	}()
	return out, nil
}

// SubscribeTrades subscribes to the trades.{instrument_name}.{interval} channel
func (e *Exchange) SubscribeTrades(instrument_name, interval string) (chan *notifications.TradesInstrumentNameIntervalRepeated, error) {
	chans := []string{fmt.Sprintf("trades.%s.%s", instrument_name, interval)}
	if _, err := e.PublicSubscribe(&public.SubscribeRequest{Channels: chans}); err != nil {
		return nil, fmt.Errorf("error subscribing to channel: %s", err)
	}
	c := make(chan *RPCNotification)
	out := make(chan *notifications.TradesInstrumentNameIntervalRepeated)
	sub := &RPCSubscription{Data: c, Channel: chans[0]}
	e.subscriptions[chans[0]] = sub

	go func() {
	Loop:
		for {
			select {
			case n := <-c:
				var ret notifications.TradesInstrumentNameIntervalRepeated
				if err := mapstructure.Decode(n.Params.Data, &ret); err != nil {
					e.errors <- fmt.Errorf("error decoding notification: %s", err)
				}
				out <- &ret
			case <-e.stop:
				break Loop
			}
		}
	}()
	return out, nil
}

// SubscribeMarkPriceOptions subscribes to the markprice.options.{index_name} channel
func (e *Exchange) SubscribeMarkPriceOptions(index_name string) (chan *notifications.MarkpriceOptionsIndexNameRepeated, error) {
	chans := []string{fmt.Sprintf("markprice.options.%s", index_name)}
	if _, err := e.PublicSubscribe(&public.SubscribeRequest{Channels: chans}); err != nil {
		return nil, fmt.Errorf("error subscribing to channel: %s", err)
	}
	c := make(chan *RPCNotification)
	out := make(chan *notifications.MarkpriceOptionsIndexNameRepeated)
	sub := &RPCSubscription{Data: c, Channel: chans[0]}
	e.subscriptions[chans[0]] = sub

	go func() {
	Loop:
		for {
			select {
			case n := <-c:
				var ret notifications.MarkpriceOptionsIndexNameRepeated
				if err := mapstructure.Decode(n.Params.Data, &ret); err != nil {
					e.errors <- fmt.Errorf("error decoding notification: %s", err)
				}
				out <- &ret
			case <-e.stop:
				break Loop
			}
		}
	}()
	return out, nil
}

// SubscribeQuote subscribes to the quote.{instrument_name} channel
func (e *Exchange) SubscribeQuote(instrument_name string) (chan *notifications.QuoteInstrumentNameRepeated, error) {
	chans := []string{fmt.Sprintf("quote.%s", instrument_name)}
	if _, err := e.PublicSubscribe(&public.SubscribeRequest{Channels: chans}); err != nil {
		return nil, fmt.Errorf("error subscribing to channel: %s", err)
	}
	c := make(chan *RPCNotification)
	out := make(chan *notifications.QuoteInstrumentNameRepeated)
	sub := &RPCSubscription{Data: c, Channel: chans[0]}
	e.subscriptions[chans[0]] = sub

	go func() {
	Loop:
		for {
			select {
			case n := <-c:
				var ret notifications.QuoteInstrumentNameRepeated
				if err := mapstructure.Decode(n.Params.Data, &ret); err != nil {
					e.errors <- fmt.Errorf("error decoding notification: %s", err)
				}
				out <- &ret
			case <-e.stop:
				break Loop
			}
		}
	}()
	return out, nil
}

// SubscribeUserOrdersInstrumentName subscribes to the user.orders.{instrument_name}.{interval} channel
func (e *Exchange) SubscribeUserOrdersInstrumentName(instrument_name, interval string) (chan *notifications.UserOrdersInstrumentNameIntervalRepeated, error) {
	chans := []string{fmt.Sprintf("user.orders.%s.%s", instrument_name, interval)}
	if _, err := e.PublicSubscribe(&public.SubscribeRequest{Channels: chans}); err != nil {
		return nil, fmt.Errorf("error subscribing to channel: %s", err)
	}
	c := make(chan *RPCNotification)
	out := make(chan *notifications.UserOrdersInstrumentNameIntervalRepeated)
	sub := &RPCSubscription{Data: c, Channel: chans[0]}
	e.subscriptions[chans[0]] = sub

	go func() {
	Loop:
		for {
			select {
			case n := <-c:
				var ret notifications.UserOrdersInstrumentNameIntervalRepeated
				if err := mapstructure.Decode(n.Params.Data, &ret); err != nil {
					e.errors <- fmt.Errorf("error decoding notification: %s", err)
				}
				out <- &ret
			case <-e.stop:
				break Loop
			}
		}
	}()
	return out, nil
}

// SubscribeUserTradesInstrument subscribes to the user.trades.{instrument_name}.{interval} channel
func (e *Exchange) SubscribeUserTradesInstrument(instrument_name, interval string) (chan *notifications.UserTradesInstrumentNameIntervalRepeated, error) {
	chans := []string{fmt.Sprintf("user.trades.%s.%s", instrument_name, interval)}
	if _, err := e.PublicSubscribe(&public.SubscribeRequest{Channels: chans}); err != nil {
		return nil, fmt.Errorf("error subscribing to channel: %s", err)
	}
	c := make(chan *RPCNotification)
	out := make(chan *notifications.UserTradesInstrumentNameIntervalRepeated)
	sub := &RPCSubscription{Data: c, Channel: chans[0]}
	e.subscriptions[chans[0]] = sub

	go func() {
	Loop:
		for {
			select {
			case n := <-c:
				var ret notifications.UserTradesInstrumentNameIntervalRepeated
				if err := mapstructure.Decode(n.Params.Data, &ret); err != nil {
					e.errors <- fmt.Errorf("error decoding notification: %s", err)
				}
				out <- &ret
			case <-e.stop:
				break Loop
			}
		}
	}()
	return out, nil
}

// SubscribeAnnouncements subscribes to the announcements channel
func (e *Exchange) SubscribeAnnouncements(instrument_name, interval string) (chan *notifications.Announcements, error) {
	chans := []string{fmt.Sprintf("announcements", instrument_name, interval)}
	if _, err := e.PublicSubscribe(&public.SubscribeRequest{Channels: chans}); err != nil {
		return nil, fmt.Errorf("error subscribing to channel: %s", err)
	}
	c := make(chan *RPCNotification)
	out := make(chan *notifications.Announcements)
	sub := &RPCSubscription{Data: c, Channel: chans[0]}
	e.subscriptions[chans[0]] = sub

	go func() {
	Loop:
		for {
			select {
			case n := <-c:
				var ret notifications.Announcements
				if err := mapstructure.Decode(n.Params.Data, &ret); err != nil {
					e.errors <- fmt.Errorf("error decoding notification: %s", err)
				}
				out <- &ret
			case <-e.stop:
				break Loop
			}
		}
	}()
	return out, nil
}

// SubscribeDeribitPriceRanking subscribes to the deribit_price_ranking.{index_name} channel
func (e *Exchange) SubscribeDeribitPriceRanking(index_name string) (chan *notifications.DeribitPriceRankingIndexNameRepeated, error) {
	chans := []string{fmt.Sprintf("deribit_price_ranking.%s", index_name)}
	if _, err := e.PublicSubscribe(&public.SubscribeRequest{Channels: chans}); err != nil {
		return nil, fmt.Errorf("error subscribing to channel: %s", err)
	}
	c := make(chan *RPCNotification)
	out := make(chan *notifications.DeribitPriceRankingIndexNameRepeated)
	sub := &RPCSubscription{Data: c, Channel: chans[0]}
	e.subscriptions[chans[0]] = sub

	go func() {
	Loop:
		for {
			select {
			case n := <-c:
				var ret notifications.DeribitPriceRankingIndexNameRepeated
				if err := mapstructure.Decode(n.Params.Data, &ret); err != nil {
					e.errors <- fmt.Errorf("error decoding notification: %s", err)
				}
				out <- &ret
			case <-e.stop:
				break Loop
			}
		}
	}()
	return out, nil
}

// SubscribeEstimatedExpirationPrice subscribes to the estimated_expiration_price.{index_name} channel
func (e *Exchange) SubscribeEstimatedExpirationPrice(index_name string) (chan *notifications.EstimatedExpirationPriceIndexNameRepeated, error) {
	chans := []string{fmt.Sprintf("estimated_expiration_price.%s", index_name)}
	if _, err := e.PublicSubscribe(&public.SubscribeRequest{Channels: chans}); err != nil {
		return nil, fmt.Errorf("error subscribing to channel: %s", err)
	}
	c := make(chan *RPCNotification)
	out := make(chan *notifications.EstimatedExpirationPriceIndexNameRepeated)
	sub := &RPCSubscription{Data: c, Channel: chans[0]}
	e.subscriptions[chans[0]] = sub

	go func() {
	Loop:
		for {
			select {
			case n := <-c:
				var ret notifications.EstimatedExpirationPriceIndexNameRepeated
				if err := mapstructure.Decode(n.Params.Data, &ret); err != nil {
					e.errors <- fmt.Errorf("error decoding notification: %s", err)
				}
				out <- &ret
			case <-e.stop:
				break Loop
			}
		}
	}()
	return out, nil
}

// SubscribePerpetual subscribes to the perpetual.{instrument_name}.{interval} channel
func (e *Exchange) SubscribePerpetual(instrument_name, interval string) (chan *notifications.PerpetualInstrumentNameIntervalRepeated, error) {
	chans := []string{fmt.Sprintf("perpetual.%s.%s", instrument_name, interval)}
	if _, err := e.PublicSubscribe(&public.SubscribeRequest{Channels: chans}); err != nil {
		return nil, fmt.Errorf("error subscribing to channel: %s", err)
	}
	c := make(chan *RPCNotification)
	out := make(chan *notifications.PerpetualInstrumentNameIntervalRepeated)
	sub := &RPCSubscription{Data: c, Channel: chans[0]}
	e.subscriptions[chans[0]] = sub

	go func() {
	Loop:
		for {
			select {
			case n := <-c:
				var ret notifications.PerpetualInstrumentNameIntervalRepeated
				if err := mapstructure.Decode(n.Params.Data, &ret); err != nil {
					e.errors <- fmt.Errorf("error decoding notification: %s", err)
				}
				out <- &ret
			case <-e.stop:
				break Loop
			}
		}
	}()
	return out, nil
}

// SubscribeUserOrdersKind subscribes to the user.orders.{kind}.{currency}.{interval} channel
func (e *Exchange) SubscribeUserOrdersKind(kind, currency, interval string) (chan *notifications.UserOrdersKindCurrencyIntervalRepeated, error) {
	chans := []string{fmt.Sprintf("user.orders.%s.%s.%s", kind, currency, interval)}
	if _, err := e.PublicSubscribe(&public.SubscribeRequest{Channels: chans}); err != nil {
		return nil, fmt.Errorf("error subscribing to channel: %s", err)
	}
	c := make(chan *RPCNotification)
	out := make(chan *notifications.UserOrdersKindCurrencyIntervalRepeated)
	sub := &RPCSubscription{Data: c, Channel: chans[0]}
	e.subscriptions[chans[0]] = sub

	go func() {
	Loop:
		for {
			select {
			case n := <-c:
				var ret notifications.UserOrdersKindCurrencyIntervalRepeated
				if err := mapstructure.Decode(n.Params.Data, &ret); err != nil {
					e.errors <- fmt.Errorf("error decoding notification: %s", err)
				}
				out <- &ret
			case <-e.stop:
				break Loop
			}
		}
	}()
	return out, nil
}

// SubscribeUserPortfolio subscribes to the user.portfolio.{currency} channel
func (e *Exchange) SubscribeUserPortfolio(currency string) (chan *notifications.UserPortfolioCurrencyRepeated, error) {
	chans := []string{fmt.Sprintf("user.portfolio.%s", currency)}
	if _, err := e.PublicSubscribe(&public.SubscribeRequest{Channels: chans}); err != nil {
		return nil, fmt.Errorf("error subscribing to channel: %s", err)
	}
	c := make(chan *RPCNotification)
	out := make(chan *notifications.UserPortfolioCurrencyRepeated)
	sub := &RPCSubscription{Data: c, Channel: chans[0]}
	e.subscriptions[chans[0]] = sub

	go func() {
	Loop:
		for {
			select {
			case n := <-c:
				var ret notifications.UserPortfolioCurrencyRepeated
				if err := mapstructure.Decode(n.Params.Data, &ret); err != nil {
					e.errors <- fmt.Errorf("error decoding notification: %s", err)
				}
				out <- &ret
			case <-e.stop:
				break Loop
			}
		}
	}()
	return out, nil
}

// SubscribeBookGroup subscribes to the book.{instrument_name}.{interval} channel
func (e *Exchange) SubscribeBookGroup(instrument_name, interval string) (chan *notifications.BookInstrumentNameGroupDepthIntervalRepeated, error) {
	chans := []string{fmt.Sprintf("book.%s.%s", instrument_name, interval)}
	if _, err := e.PublicSubscribe(&public.SubscribeRequest{Channels: chans}); err != nil {
		return nil, fmt.Errorf("error subscribing to channel: %s", err)
	}
	c := make(chan *RPCNotification)
	out := make(chan *notifications.BookInstrumentNameGroupDepthIntervalRepeated)
	sub := &RPCSubscription{Data: c, Channel: chans[0]}
	e.subscriptions[chans[0]] = sub

	go func() {
	Loop:
		for {
			select {
			case n := <-c:
				var ret notifications.BookInstrumentNameGroupDepthIntervalRepeated
				if err := mapstructure.Decode(n.Params.Data, &ret); err != nil {
					e.errors <- fmt.Errorf("error decoding notification: %s", err)
				}
				out <- &ret
			case <-e.stop:
				break Loop
			}
		}
	}()
	return out, nil
}

// SubscribeDeribitPriceIndex subscribes to the deribit_price_index.{index_name} channel
func (e *Exchange) SubscribeDeribitPriceIndex(index_name string) (chan *notifications.DeribitPriceIndexIndexNameRepeated, error) {
	chans := []string{fmt.Sprintf("deribit_price_index.%s", index_name)}
	if _, err := e.PublicSubscribe(&public.SubscribeRequest{Channels: chans}); err != nil {
		return nil, fmt.Errorf("error subscribing to channel: %s", err)
	}
	c := make(chan *RPCNotification)
	out := make(chan *notifications.DeribitPriceIndexIndexNameRepeated)
	sub := &RPCSubscription{Data: c, Channel: chans[0]}
	e.subscriptions[chans[0]] = sub

	go func() {
	Loop:
		for {
			select {
			case n := <-c:
				var ret notifications.DeribitPriceIndexIndexNameRepeated
				if err := mapstructure.Decode(n.Params.Data, &ret); err != nil {
					e.errors <- fmt.Errorf("error decoding notification: %s", err)
				}
				out <- &ret
			case <-e.stop:
				break Loop
			}
		}
	}()
	return out, nil
}

// SubscribeTicker subscribes to the ticker.{instrument_name}.{interval} channel
func (e *Exchange) SubscribeTicker(instrument_name, interval string) (chan *notifications.TickerInstrumentNameIntervalRepeated, error) {
	chans := []string{fmt.Sprintf("ticker.%s.%s", instrument_name, interval)}
	if _, err := e.PublicSubscribe(&public.SubscribeRequest{Channels: chans}); err != nil {
		return nil, fmt.Errorf("error subscribing to channel: %s", err)
	}
	c := make(chan *RPCNotification)
	out := make(chan *notifications.TickerInstrumentNameIntervalRepeated)
	sub := &RPCSubscription{Data: c, Channel: chans[0]}
	e.subscriptions[chans[0]] = sub

	go func() {
	Loop:
		for {
			select {
			case n := <-c:
				var ret notifications.TickerInstrumentNameIntervalRepeated
				if err := mapstructure.Decode(n.Params.Data, &ret); err != nil {
					e.errors <- fmt.Errorf("error decoding notification: %s", err)
				}
				out <- &ret
			case <-e.stop:
				break Loop
			}
		}
	}()
	return out, nil
}

// SubscribeUserTradesKind subscribes to the user.trades.{kind}.{currency}.{interval} channel
func (e *Exchange) SubscribeUserTradesKind(kind, currency, interval string) (chan *notifications.UserTradesKindCurrencyIntervalRepeated, error) {
	chans := []string{fmt.Sprintf("user.trades.%s.%s.%s", kind, currency, interval)}
	if _, err := e.PublicSubscribe(&public.SubscribeRequest{Channels: chans}); err != nil {
		return nil, fmt.Errorf("error subscribing to channel: %s", err)
	}
	c := make(chan *RPCNotification)
	out := make(chan *notifications.UserTradesKindCurrencyIntervalRepeated)
	sub := &RPCSubscription{Data: c, Channel: chans[0]}
	e.subscriptions[chans[0]] = sub

	go func() {
	Loop:
		for {
			select {
			case n := <-c:
				var ret notifications.UserTradesKindCurrencyIntervalRepeated
				if err := mapstructure.Decode(n.Params.Data, &ret); err != nil {
					e.errors <- fmt.Errorf("error decoding notification: %s", err)
				}
				out <- &ret
			case <-e.stop:
				break Loop
			}
		}
	}()
	return out, nil
}
